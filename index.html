<html>
  <head>
    <title>JSchema</title>
    <link rel="stylesheet" type="text/css" href="style.css" />
  </head>
  <body>
    <center>
      <h1>JSchema</h1>
      <p><i>An experiment in simplicity</i></p>
      <p><i>See also <a href="rpc.html">jschema-rpc</a></i></p>
    </center>
    <h2>Introduction</h2>
    <p>
      The great virtue of JSON is that it is simple.  Its grammar consists of 15 productions, making it both easy to parse and produce.
    </p>
    <p>
      A simple data interchange format demands a simple schema mechanism.  Sadly, the current schema standard, <a href="http://json-schema.org">JSON Schema</a>, is not.
    </p>
    <p>
      JSchema fills this gap.  The design goals of JSchema are:
      <ul>
        <li>Its grammar should be at most 15 productions beyond JSON</li>
        <li>It should be flexible enough to specify most existing JSON content</li>
        <li>It should communicate the structure of the JSON document visually</li>
        <li>It should map cleanly to standard programming language concepts and data structures</li>
      </ul>
    </p>
    <p>
      In order to retain simplicity it is necessary to forego some features.  JSchema does not support:
      <ul>
        <li>Fine-grained schema mixing</li>
        <li>Subtyping/specialization</li>
        <li>Various useful data types (e.g. intervals)</li>
      </ul>
    </p>
    <h2>Schema URL and File Conventions</h2>
    <p>
      Assuming JSON content matching a given JSchema is available at <pre>http://example.com/path/</pre> then the JSchema should be available at <pre>http://example.com/path/?JSchema</pre>
    </p>
    <p>
      Locally, JSchema files should end with the <code>.jsc</code> file suffix.
    </p>
    <h2>Grammar</h2>
    <pre>
&lt;type> ::= 
  &lt;core_types> |
  &lt;struct_type> |
  <a href="#type_defs">&lt;string></a> |
  &lt;array_type> |
  &lt;map_type> |
  &lt;enum_type> |
  &lt;ref_type>

<a name="core_type_g">&lt;core_types></a> ::=
  <a href="#string_type">'"string"'</a> |
  <a href="#boolean_type">'"boolean"'</a> |
  <a href="#date_type">'"date"'</a> |
  <a href="#integer_type">'"integer"'</a> |
  <a href="#decimal_type">'"decimal"'</a> |
  <a href="#biginteger_type">'"biginteger"'</a> |
  <a href="#bigdecimal_type">'"bigdecimal"'</a> |
  <a href="#self_type">'"self"'</a> |
  <a href="#object_type">'"object"'</a>

<a href="#struct_type">&lt;struct_type></a> ::= 
  '{' &lt;typedefs_and_props> '}'

&lt;typedefs_and_props> ::= 
    &lt;typedefs_map> ',' &lt;props> |
    &lt;props> |

&lt;typedefs_map> ::= 
    '"typedefs@"' ':' '{' &lt;type_defs> '}'

<a href="#type_defs">&lt;type_defs></a> ::= 
  &lt;type_def> |
  &lt;type_def> ',' &lt;type_defs>

&lt;type_def> ::= 
  &lt;string> ':' &lt;type_def_type>

&lt;type_def_type> ::= 
    &lt;struct_type> |
    &lt;enum_type>

&lt;props> ::= 
  &lt;prop> |
  &lt;prop> ',' &lt;props>

&lt;prop> ::= 
  &lt;string> ':' &lt;type>

<a href="#array_type">&lt;array_type></a> ::= 
  '[' type ']'

<a href="#array_type">&lt;map_type></a> ::=
  '{' '"map_of"' ':' &lt;type> '}'

<a href="#enum_type">&lt;enum_type></a> ::= 
  '{' '"enum"' ':' '[' &lt;enum_values> ']' '}'

&lt;enum_values> ::=
  string
  string ',' &lt;enum_values>

<a href="#ref_type">&lt;ref_type></a> ::=
  '{' '"ref@"' ':' string '}'
    </pre>
    
  <h2>Types</h2>

  <a name="string_type"><h3>"string"</h3></a>
  <p>
    A string may have a value of a standard JSON string.
  </p>

  <a name="boolean_type"><h3>"boolean"</h3></a>
  <p>
    A boolean may have a value of 'true' or 'false', sans quotes, per the JSON specification.
  </p>

  <a name="date_type"><h3>"date"</h3></a>
  <p>
    A date may have a value of a standard JSON string in any format specified by the W3C <a href="http://www.w3.org/TR/NOTE-datetime">NOTE-datetime</a>.
  </p>

  <a name="integer_type"><h3>"integer"</h3></a>
  <p>
    An integer may be a JSON int representing any 64-bit signed integer.  Environments unable to represent 64-bit integers (e.g. Javascript) may raise an error if a value cannot be represented.
  </p>

  <a name="biginteger_type"><h3>"biginteger"</h3></a>
  <p>
    A biginteger may be a JSON int representing a signed integer of arbitrary size.
  </p>

  <a name="decimal_type"><h3>"decimal"</h3></a>
  <p>
    A decimal may be a JSON number representing any double precision 64-bit floating point number.
  </p>

  <a name="decimal_type"><h3>"bigdecimal"</h3></a>
  <p>
    A bigdecimal may be a JSON number representing any number of arbitrary size and precision.
  </p>

  <a name="self_type"><h3>"self"</h3></a>
  <p>
    "self" refers to the schema defined by the current JSchema file.  This can be used to define recursive schemas, such as trees.
  </p>

  <a name="object_type"><h3>"object"</h3></a>
  <p>
    An object can be any arbitrary JSON object
  </p>

  <a name="struct_type"><h3>Struct Type</h3></a>
  <p>
    A struct type defines a JSON object by a series of name/type pairs. A conforming JSON object may not have a value for every name in the struct specification, and the value should be considered null if it is not present.  Additionally, fields not mentioned in the Struct Type may be present and should be preserved at runtime for re-serialization.
  </p>

  <a name="type_defs"><h3>Struct TypeDefs</h3></a>
  <p>
    A struct type may define other types to refer to by name using the 'typedef@' syntax. A typedef consists of a string name and a type definition.  The name of each typedef must be unique and not conflict with the core type names.  Typedef names are valid within the context of the struct type they are defined in.
  </p>
  <p>
    Typedefs may be either Struct Types or Enum Types.
  </p>

  <a name="array_type"><h3>Array Type</h3></a>
  <p>
    An array type defines a JSON Array and the elements it contains.
  </p>

  <a name="map_type"><h3>Map Type</h3></a>
  <p>
    A map type defines a JSON object with arbitrary members.  For each member in the JSON object, the member value must satisfy the type definition.
  </p>

  <a name="enum_type"><h3>Enum Type</h3></a>
  <p>
    An enum must have a string value from domain specified.
  </p>

  <a name="ref_type"><h3>Ref Type</h3></a>
  <p>
    A ref type is a reference to a jschema document.  The second element is a URL that the jschema content can be retrieved from.
  </p>

  <h2>Nullability</h2>
  <p>
    All values in a JSchema schema are nullable.  The interpretation of the null value is left to implementations, with the caveat that null should be preserved for re-serialization.  Additionally, absent values in a JSON object should be interpreted as null.
  </p>

  <h2>Comments</h2>
  <p>
    JSchema implementations are required to <a href="http://tech.groups.yahoo.com/group/json/message/152">accept c-style comments</a> in JSchema files.
  </p>

  <h2>Examples</h2>
  <table class="examples-table">
    <tr>
      <th>
        Schema
      </th>
      <th>
        Examples
      </th>
    </tr>
    <tr>
      <td>
{ "name" : "string", "age" : "integer" }
      </td>
      <td>
{ "name" : "Joe", "age" : 42 }
      </td>
    </tr>
    <tr>
      <td>
{ "people" : [ { "name" : "string", 
                 "age" : "integer"} ] }
      </td>
      <td>
{ "people" : [
  { "name" : "Joe", "age" : 42 }
  { "name" : "Paul", "age" : 28 }
  { "name" : "Mack", "age" : 55 } ] }
      </td>
    </tr>
    <tr>
      <td>
{ "people" : [ { "name" : "string", 
                 "age" : "integer"} ] }
      </td>
      <td>
{ "people" : [
  { "name" : "Joe", "age" : 42 },
  { "name" : "Paul", "age" : 28 },
  { "name" : "Mack", "age" : 55 } ] }
      </td>
    </tr>
    <tr>
      <td>
{ "people" : [ { "name" : "string", 
                 "age" : "integer",
                 "eye_color" : {"enum" : ["brown", 
                                          "blue", 
                                          "green"]}} ] }
      </td>
      <td>
{ "people" : [
  { "name" : "Joe", "age" : 42, "eye_color" : "brown" },
  { "name" : "Paul", "age" : 28, "eye_color" : "brown" },
  { "name" : "Mack", "age" : 55, "eye_color" : "blue" } ] }
      </td>
    </tr>
    <tr>
      <td>
{ "id_to_people" : {
    "map_of" : { "name" : "string", 
                 "age" : "integer",
                 "eye_color" : {"enum" : ["brown", 
                                          "blue", 
                                          "green"]}
    }
  }
}
      </td>
      <td>
{ "id_to_people" : {
    "1" : { "name" : "Joe", "age" : 42, "eye_color" : "brown" },
    "2" : { "name" : "Paul", "age" : 28, "eye_color" : "brown" },
    "3" : { "name" : "Mack", "age" : 55, "eye_color" : "blue" }
  }
}
      </td>
    </tr>
  <table>
  </body>
</html>
