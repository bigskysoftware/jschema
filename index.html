<html>
  <head>
    <title>Simple JSON Schema</title>
    <link rel="stylesheet" type="text/css" href="style.css" />
  </head>
  <body>
    <center>
      <h1>Simple JSON Schema</h1>
      <p><i>See also <a href="simplejsonrpc.html">Simple JSON RPC</a></i></p>
    </center>
    <h2>Introduction</h2>
    <p>
      One of the great advantages of JSON is the fact that it is so simple.  Its grammar consists of fifteen easily understood productions.  It is both easy to parse and produce.
    </p>
    <p>
      A simple data interchange format demands a simple schema system.  Unfortunately the current standard schema for JSON, <a href="http://json-schema.org">JSON Schema</a> is quite complicated, deriving many of its ideas from the XML-based schemas.
    </p>
    <p>
      The goal of Simple JSON Schema is to provide a simplified way to specify the structure of JSON content in a way that facilitates working with the content in a programming language environment.  The design points are:
      <ul>
        <li>Its grammar must be as simple as JSON itself</li>
        <li>It should provide enough flexibility to encompass most existing JSON content</li>
        <li>It should communicate the structure of the JSON document visually</li>
        <li>It should easily map to standard programming language concepts and data structures</li>
      </ul>
    </p>
    <p>
      In order to retain simplicity, it is necessary to forego useful features.  Some of the things that Simple JSON Schema does not allow are:
      <ul>
        <li>Named schema elements, which percludes recursive data structures, such as arbitrary depth trees.  Such structures can be modeled by a user using JSON attributes.</li>
        <li>Inter-schema references.  Library writers are encouraged to support <a href="http://en.wikipedia.org/wiki/Structural_type_system">structural typing</a> and similar concepts in their libraries to facilitate cross-schema data migration.</li>
        <li>Various useful data types (e.g. intervals).  The core primitive data types of Simple JSON Schema can be composed to represent data types.</li>
      </ul>
    </p>
    <h2>Schema URL Convention</h2>
    <p>
      Assuming JSON content matching a given schema is at <pre>http://example.com/path/</pre> then the Simple JSON Schema should be available at <pre>http://example.com/path/?SimpleJSONSchema</pre>
    </p>
    <h2>Grammar</h2>
    <pre>
&lt;type> ::= 
  &lt;core_types> |
  &lt;struct_type> |
  &lt;array_type> |
  &lt;map_type> |
  &lt;enum_type>

<a name="core_type_g">&lt;core_types></a> ::=
  <a href="#string_type">"string"</a> |
  <a href="#boolean_type">"boolean"</a> |
  <a href="#date_type">"date"</a> |
  <a href="#integer_type">"integer"</a> |
  <a href="#decimal_type">"decimal"</a> |
  <a href="#biginteger_type">"biginteger"</a> |
  <a href="#bigdecimal_type">"bigdecimal"</a>

<a href="#struct_type">&lt;struct_type></a> ::= 
  '{' &lt;props> '}'

&lt;props> ::= 
  prop |
  prop ',' props

&lt;prop> ::= 
  string ':' &lt;type>

<a href="#array_type">&lt;array_type></a> ::= 
  '[' type ']'

<a href="#array_type">&lt;map_type></a> ::=
  '{' "map_of" ':' '{' 'key' ':' &lt;type>, 'value' ':' &lt;type>  '}' '}'

<a href="#enum_type">&lt;enum_type></a> ::= 
  '{' "enum" ':' '[' &lt;enum_values> ']' '}'

&lt;enum_values> ::=
  string
  string ',' &lt;enum_values>
    </pre>
    
  <h2>Types</h2>

  <a name="string_type"><h3>"string"</h3></a>
  <p>
    A string may have a value of a standard UTF-8 string.
  </p>

  <a name="boolean_type"><h3>"boolean"</h3></a>
  <p>
    A boolean may have a value of either "true" or "false".
  </p>

  <a name="date_type"><h3>"date"</h3></a>
  <p>
    A date may have a value of a standard UTF-8 string in any format specified by the W3C <a href="http://www.w3.org/TR/NOTE-datetime">NOTE-datetime</a>.
  </p>

  <a name="integer_type"><h3>"integer"</h3></a>
  <p>
    An integer may have a string representing any 32-bit signed integer.
  </p>

  <a name="biginteger_type"><h3>"biginteger"</h3></a>
  <p>
    An integer may have a string representing a signed integer of arbitrary size.
  </p>

  <a name="decimal_type"><h3>"decimal"</h3></a>
  <p>
    An integer may have a string representing any double precision 64-bit floating point number.
  </p>

  <a name="decimal_type"><h3>"bigdecimal"</h3></a>
  <p>
    An integer may have a string representing floating point number of arbitrary size and precision.
  </p>

  <a name="struct_type"><h3>Struct Type</h3></a>
  <p>
    A struct type defines a structure for a JSON object.  To be valid, for every name/type defined in the struct, there must be a JSON pair with that name as the first value and a JSON value satisfying the type.
  </p>

  <a name="array_type"><h3>Array Type</h3></a>
  <p>
    An array type defines defines the values of a JSON Array.
  </p>

  <a name="map_type"><h3>Map Type</h3></a>
  <p>
    A map type defines defines the values of a JSON object.  To be valid, for each pair in the JSON object, the first value must satisfy the first type definition and the second value must satisfy the second type definition.
  </p>

  <a name="enum_type"><h3>Enum Type</h3></a>
  <p>
    An enum may have a string value from domain specified.
  </p>

  <h2>Examples</h2>
  <table class="examples-table">
    <tr>
      <th>
        Schema
      </th>
      <th>
        Examples
      </th>
    </tr>
    <tr>
      <td>
{ "name" : "string", "age" : "integer" }
      </td>
      <td>
{ "name" : "Joe", "age" : "42" }
      </td>
    </tr>
    <tr>
      <td>
{ "people" : [ { "name" : "string", 
                 "age" : "integer"} ] }
      </td>
      <td>
{ "people" : [
  { "name" : "Joe", "age" : "42" }
  { "name" : "Paul", "age" : "28" }
  { "name" : "Mack", "age" : "55" } ] }
      </td>
    </tr>
    <tr>
      <td>
{ "people" : [ { "name" : "string", 
                 "age" : "integer"} ] }
      </td>
      <td>
{ "people" : [
  { "name" : "Joe", "age" : "42" },
  { "name" : "Paul", "age" : "28" },
  { "name" : "Mack", "age" : "55" } ] }
      </td>
    </tr>
    <tr>
      <td>
{ "people" : [ { "name" : "string", 
                 "age" : "integer",
                 "eye_color" : {"enum" : ["brown", 
                                          "blue", 
                                          "green"]}} ] }
      </td>
      <td>
{ "people" : [
  { "name" : "Joe", "age" : "42", "eye_color" : "brown" },
  { "name" : "Paul", "age" : "28", "eye_color" : "brown" },
  { "name" : "Mack", "age" : "55", "eye_color" : "blue" } ] }
      </td>
    </tr>
    <tr>
      <td>
{ "id_to_people" : {
    "map_of" : {
    "key" : "biginteger",
    "value" : { "name" : "string", 
                "age" : "integer",
                "eye_color" : {"enum" : ["brown", 
                                         "blue", 
                                         "green"]} }
    }
  }
}
      </td>
      <td>
{ "id_to_people" : {
    "1" : { "name" : "Joe", "age" : "42", "eye_color" : "brown" },
    "2" : { "name" : "Paul", "age" : "28", "eye_color" : "brown" },
    "3" : { "name" : "Mack", "age" : "55", "eye_color" : "blue" }
  }
}
      </td>
    </tr>
  <table>
  </body>
</html>